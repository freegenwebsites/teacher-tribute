<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Retiring Teacher Tribute Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Create a tribute board for a retiring teacher with hover animations, fan-like stacking image gallery, edit/delete features, and mobile-friendly design.">
  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css">
  <!-- Google Fonts: Indie Flower (cute headlines), Quicksand (body) -->
  <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(120deg, #f9ecff 0%, #e9e1ff 100%);
      font-family: 'Quicksand', 'Indie Flower', cursive, sans-serif;
      min-height: 100vh;
    }
    .card-animated {
      transition:
        transform 0.21s cubic-bezier(.34,1.56,.64,1),
        box-shadow 0.22s;
      will-change: transform, box-shadow;
      background: linear-gradient(135deg,#fcf3ff 70%, #e6d5f7 100%);
      position: relative; /* Needed for absolute positioning of buttons */
      overflow: visible; /* Allow buttons/tooltips outside */
      margin-bottom: 6px; /* Added margin from original card style */
    }
    .card-animated:hover, .card-animated.mobile-anim {
      transform: translateY(-8px) scale(1.045) rotate(-1.5deg);
      box-shadow: 0 15px 44px rgba(200,138,255,.18), 0 1.5px 8px rgba(122,122,216,.13);
      z-index:10;
    }
    /* Ensure edit form doesn't get the hover transform */
    .card-animated.editing {
        transform: none !important;
        box-shadow: 0 4px 12px rgba(200,138,255,.10) !important; /* Subtle shadow while editing */
        z-index: 5; /* Below hovered cards */
    }
    .tribute-title {
      font-family: 'Indie Flower', cursive;
      color: #b366d1;
      text-shadow: 0 2px 7px #fed6f5a5;
      font-size: 2.07rem;
      letter-spacing: 1.5px;
    }
    .tribute-quote {
      font-family: 'Indie Flower', cursive;
      color: #6d4fa8;
      font-size:1.07rem;
      opacity: .9;
      text-align: center;
    }
    .cute-btn {
      background: linear-gradient(90deg, #fccb90 0%, #d57eea 100%);
      transition: background 0.14s, box-shadow 0.14s;
    }
    .cute-btn:hover {
      background: linear-gradient(90deg, #fcb6c0 0%, #a16ae8 100%);
      box-shadow: 0 4px 15px rgba(213, 126, 234, 0.3);
    }
    /* Floating hearts in the background for cuteness */
    .floating-heart {
      position: absolute;
      font-size: 1.23rem;
      opacity: 0.15;
      pointer-events:none;
      animation: floatHeart 10s linear infinite;
      z-index: 0;
    }
    @keyframes floatHeart {
      0% {transform: translateY(50px) scale(1.09);}
      100% {transform: translateY(-200px) scale(1);}
    }
    /* Fan Gallery Stacking Effect */
    .fan-gallery {
      position: relative;
      height:126px;
      width:156px;
      margin:0 auto 0.8rem auto;
      display:flex;
      align-items: flex-end;
      justify-content: center;
      z-index:4;
      pointer-events: none; /* Container doesn't block clicks */
    }
    .fan-img {
      position: absolute;
      left:50%; bottom:0;
      width:105px;height:120px;
      object-fit:cover;
      object-position: center top;
      border-radius: 13px;
      box-shadow: 0 2px 12px 0 rgba(156,108,200,0.14);
      background: #faf7ff;
      border: 2px solid #f3deff;
      cursor:pointer;
      pointer-events:auto; /* Images are clickable */
      opacity:.93;
      transition:
        box-shadow 0.22s cubic-bezier(.34,1.56,.64,1),
        transform .23s cubic-bezier(.4,1.8,.6,.75),
        z-index .22s,
        filter .14s;
      will-change: transform, box-shadow, filter;
    }
    .fan-img:hover, .fan-img:focus {
      box-shadow: 0 8px 24px rgba(199,136,255,0.23);
      filter: brightness(1.08);
      z-index:23!important; /* High z-index on hover/focus */
      transform: scale(1.16) rotate(0deg)!important;
    }
    .fan-gallery .fan-img.fan-anim { /* Class added dynamically */
      filter: brightness(1.09) drop-shadow(0 0 15px #f9e1ff73);
      transform: scale(1.14) rotate(0deg)!important;
      z-index:30!important; /* Even higher for active animation */
    }
    /* Scrollbar styling */
    ::-webkit-scrollbar { width:8px;}
    ::-webkit-scrollbar-thumb { background: #e5d0fd; border-radius: 10px;}
    ::-webkit-scrollbar-track { background: #f8f0ff;}

    /* Tooltip Styling (for Edit/Delete buttons) */
    [data-tooltip] {
      position: relative;
      cursor: pointer;
    }
    [data-tooltip]:hover::after,
    [data-tooltip]:focus::after {
      opacity:1;visibility:visible;
      transition: opacity .15s .3s; /* Add slight delay */
    }
    [data-tooltip]::after {
      opacity: 0; visibility: hidden;
      position: absolute;
      left: 50%;
      bottom: 120%; /* Position above the button */
      transform:translateX(-50%);
      background: #6a3a8a; /* Darker background for contrast */
      color: #ffffff;
      font-size: .78rem; /* Smaller font */
      font-family: 'Quicksand', sans-serif;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 6px;
      content: attr(data-tooltip);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      white-space:nowrap; /* Keep on one line */
      z-index:111; /* Ensure tooltip is on top */
      pointer-events: none; /* Tooltip shouldn't be interactive */
    }

    /* Edit Form Specific Styles */
     .edit-tribute-form .edit-input,
     .edit-tribute-form .edit-textarea {
        font-family: 'Quicksand', sans-serif; /* Use body font for inputs */
     }
     .edit-tribute-form .edit-textarea {
        font-family:'Indie Flower',cursive; /* Keep message area cute */
        font-size:1.13rem;
     }
     .edit-tribute-form .remove-img {
        line-height: 1.5rem; /* Adjust for better icon centering */
     }
     .edit-tribute-form label {
        display: block; /* Make label take full width */
        padding: 5px 0;
        border: 1px dashed #dcb8ff;
        border-radius: 8px;
        background-color: #fdfaff;
     }
     .edit-tribute-form label:hover {
        background-color: #f9f0ff;
        border-color: #c59dfc;
     }

  </style>
</head>
<body class="relative min-h-screen pb-14">
  <!-- Cute background hearts -->
  <span class="floating-heart left-10 top-24" style="animation-delay: 0s; color:#f890b4;"><i class="fa-solid fa-heart"></i></span>
  <span class="floating-heart left-1/2 top-14" style="animation-delay:1.7s; color:#dcb8ff;"><i class="fa-solid fa-heart"></i></span>
  <span class="floating-heart right-6 top-32" style="animation-delay:0.5s; color:#fcddec;"><i class="fa-solid fa-heart"></i></span>
  <span class="floating-heart left-1/3 top-36" style="animation-delay:2.2s; color:#fcb6c0;"><i class="fa-solid fa-heart"></i></span>

  <!-- Header -->
  <div class="text-center mt-8 px-4">
    <h1 class="tribute-title mb-2">üå∏ Happy Retirement, Teacher!</h1>
    <p class="tribute-quote max-w-2xl mx-auto">
      ‚ÄúA truly great teacher is hard to find, difficult to part with, and impossible to forget.‚Äù<br>
      <span class="text-pink-400 font-semibold">Leave a note or upload your pictures below!</span>
    </p>
  </div>

  <!-- Form -->
  <div class="w-full max-w-4xl mx-auto mt-8 px-2">
    <form id="tributeForm" class="mb-8 p-4 bg-white rounded-2xl shadow-lg flex flex-wrap items-center justify-between border-2 border-purple-50" autocomplete="off">
      <div class="flex flex-col w-full sm:w-1/4 mb-2 sm:mb-0 sm:pr-2">
        <label for="fromName" class="text-purple-500 font-semibold mb-1 text-sm">Your Name</label>
        <input id="fromName" name="fromName" type="text" class="rounded-xl border border-purple-200 px-3 py-2 focus:ring-2 focus:ring-pink-200 focus:outline-none text-sm" maxlength="32" required autocomplete="off" placeholder="E.g. Jamie">
      </div>
      <div class="flex flex-col w-full sm:w-1/2 sm:px-2 mb-2 sm:mb-0">
        <label for="message" class="text-purple-500 font-semibold mb-1 text-sm">Message</label>
        <textarea id="message" name="message" rows="2" class="rounded-xl border border-purple-200 px-3 py-2 focus:ring-2 focus:ring-pink-200 focus:outline-none text-sm" maxlength="220" required placeholder="Your message..."></textarea>
      </div>
      <div class="flex flex-col w-full sm:w-1/6 sm:pl-2 mb-2 sm:mb-0">
        <label for="photos" class="text-purple-500 font-semibold mb-1 text-sm">Photo(s)
          <span class="text-xs font-normal text-gray-400">(max 4)</span>
        </label>
        <input id="photos" name="photos" type="file" multiple accept="image/*,.heic,.heif" class="border rounded-xl py-1.5 px-1 text-xs bg-purple-50 cursor-pointer file:mr-2 file:py-1 file:px-2 file:rounded-md file:border-0 file:text-xs file:font-semibold file:bg-violet-100 file:text-violet-700 hover:file:bg-violet-200">
      </div>
      <div class="w-full sm:w-auto flex items-end justify-start sm:justify-end mt-2 sm:mt-0">
        <button type="submit" class="cute-btn hover:shadow-lg font-bold py-2 px-7 text-white rounded-xl focus:outline-none transition-transform transform active:scale-95 text-sm">
          <i class="fa-solid fa-paper-plane mr-1"></i> Share
        </button>
      </div>
    </form>

    <!-- Cards grid -->
    <div id="tributesGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
        <!-- Tribute cards will be inserted here by JavaScript -->
    </div>
    <div id="emptyState" class="text-center text-purple-300 italic mt-10 text-lg hidden">
      <i class="fa-solid fa-star fa-bounce mr-2"></i>No tributes yet. Be the first to post your message!
    </div>
  </div>

  <!-- Modal for photo gallery -->
  <div id="galleryModal" class="fixed inset-0 bg-black bg-opacity-40 backdrop-blur-sm z-50 hidden flex items-center justify-center cursor-pointer transition-all duration-300 ease-out opacity-0" style="transition-property: opacity;">
    <div class="absolute inset-0" id="modalBG"></div>
    <div class="relative bg-white rounded-2xl shadow-2xl max-w-2xl w-11/12 mx-auto flex flex-col items-center px-2 py-5 border-2 border-purple-100 transform scale-95 opacity-0 transition-all duration-300 ease-out" style="transition-property: opacity, transform;">
      <button type="button" id="closeModalBtn" class="absolute right-2 top-2 text-2xl text-purple-500 hover:text-pink-400 focus:outline-none z-10" title="Close (Esc)">
        <i class="fa-solid fa-xmark"></i>
      </button>
      <div class="w-full flex items-center justify-center mb-3">
        <button type="button" id="prevImgBtn" class="text-xl text-purple-300 hover:text-purple-600 px-3 focus:outline-none hidden disabled:opacity-30 disabled:cursor-not-allowed" title="Previous (‚Üê)">
          <i class="fa-solid fa-chevron-left"></i>
        </button>
        <div id="modalImgContainer" class="max-w-xs sm:max-w-md md:max-w-lg lg:max-w-xl rounded-xl overflow-hidden bg-gray-50 shadow-inner flex-grow flex items-center justify-center">
          <img id="modalImg" src="" alt="Gallery Image" class="object-contain mx-auto block" style="max-height:65vh;">
        </div>
        <button type="button" id="nextImgBtn" class="text-xl text-purple-300 hover:text-purple-600 px-3 focus:outline-none hidden disabled:opacity-30 disabled:cursor-not-allowed" title="Next (‚Üí)">
          <i class="fa-solid fa-chevron-right"></i>
        </button>
      </div>
      <div id="galleryCaption" class="text-center text-xs mt-2 mb-1 text-gray-600 font-medium"></div>
    </div>
  </div>

  <footer class="w-full text-center py-7 mt-10 text-gray-400 text-base">
    <i class="fa-solid fa-cake-candles text-pink-300"></i>
    <span>Made with üíù for an unforgettable teacher's new adventure.</span>
  </footer>

<script>
// --- Configuration & Starter Data ---
const TRIBUTES_STORAGE_KEY = "teacherTributesV3_EditDelete"; // Use a distinct key
const MAX_PHOTOS = 4;
const MAX_PHOTO_SIZE_MB = 5; // 5MB limit per photo
const MAX_NAME_LENGTH = 32;
const MAX_MSG_LENGTH = 220;

const starterTributes = [
  { id: "starter-1", from: "Zoe", msg: "Thank you for being such a patient and inspiring teacher. Happy retirement!", date: "May 17, 2024", photos: ["https://images.unsplash.com/photo-1464983953574-0892a716854b?auto=format&fit=facearea&w=320&h=220&facepad=1"] },
  { id: "starter-2", from: "Ming", msg: "I'll always remember your fun lessons and kind smile. You made school a happy place!", date: "May 18, 2024", photos: [] },
  { id: "starter-3", from: "Alicia", msg: "Wishing you endless days of gardening and naps. You‚Äôve earned it!", date: "May 18, 2024", photos: ["https://images.unsplash.com/photo-1444065381814-865dc9da92c0?auto=format&fit=facearea&w=320&h=220&facepad=2", "https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=facearea&w=320&h=220&facepad=1", "https://images.unsplash.com/photo-1465101046530-73398c7f28ca?auto=format&fit=facearea&w=320&h=220"] }
];

// --- Utility Functions ---
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 7);
}

function getTributes() {
  const stored = localStorage.getItem(TRIBUTES_STORAGE_KEY);
  if (stored) {
    try {
      let parsedTributes = JSON.parse(stored);
      // Basic validation: ensure it's an array and items have basic structure
      if (Array.isArray(parsedTributes) && parsedTributes.every(t => typeof t === 'object' && t !== null)) {
          // Ensure all tributes have an ID (for robustness, though less critical now)
          parsedTributes.forEach(t => { if (!t.id) t.id = generateId(); });
          return parsedTributes;
      } else {
          console.warn("Invalid data found in localStorage. Resetting to starters.");
          // Add IDs to starters if they don't have them
          starterTributes.forEach(t => { if (!t.id) t.id = generateId(); });
          saveTributes(starterTributes); // Save valid starters back
          return [...starterTributes];
      }
    } catch (e) {
      console.error("Failed to parse tributes from localStorage:", e, ". Resetting to starters.");
      starterTributes.forEach(t => { if (!t.id) t.id = generateId(); });
      saveTributes(starterTributes);
      return [...starterTributes];
    }
  }
  // If nothing in storage, initialize with starters (ensure they have IDs)
  starterTributes.forEach(t => { if (!t.id) t.id = generateId(); });
  return [...starterTributes];
}

function saveTributes(arr) {
  if (Array.isArray(arr)) {
    try {
        localStorage.setItem(TRIBUTES_STORAGE_KEY, JSON.stringify(arr));
    } catch (e) {
        console.error("Failed to save tributes to localStorage:", e);
        alert("Could not save tributes. Local storage might be full or disabled.");
    }
  } else {
    console.error("Attempted to save non-array to tributes storage.");
  }
}

function formatNow() {
  const d = new Date();
  return d.toLocaleDateString("en-US", { month: 'short', day: 'numeric', year: 'numeric' });
}

function escapeHtml(str) {
  if (typeof str !== 'string') return '';
  const entityMap = {'&':'&','<':'<','>':'>','"':'"',"'":'''};
  return str.replace(/[&<>"']/g, s => entityMap[s] || s);
}

function revokeBlobUrl(url) {
  if (url && typeof url === 'string' && url.startsWith('blob:')) {
    try {
      URL.revokeObjectURL(url);
      // console.log("Revoked blob URL:", url); // Optional: for debugging
    } catch (e) {
      console.warn("Failed to revoke blob URL:", url, e);
    }
  }
}

// --- Global State ---
let tributes = getTributes(); // Load tributes initially
let currentModalTributeIdx = 0;
let currentModalPhotoIdx = 0;

// --- Rendering Functions ---

function renderFanGallery(photos, tributeIdx) {
  const tribute = tributes[tributeIdx]; // Get the tribute object
  if (!tribute) return ''; // Should not happen if idx is valid

  const fromName = escapeHtml(tribute.from || 'tribute'); // Get name for alt text

  if (!photos || !photos.length) return `
    <div class="w-full flex items-center justify-center mb-4 h-[126px]"> <!-- Ensure consistent height -->
      <div class="w-20 h-20 flex items-center justify-center text-pink-300 rounded-full bg-pink-50 border-2 border-pink-100 shadow text-3xl">
        <i class="fa-solid fa-flower"></i>
      </div>
    </div>
  `;

  let imgs = '';
  const n = photos.length;
  const maxSpread = 30; // Max total angle spread
  const baseShift = 29; // Horizontal shift per image

  for (let i = 0; i < n; i++) {
    let rot = 0;
    if (n > 1) {
      const angleStep = Math.min(maxSpread / (n - 1), 10);
      rot = (i - (n - 1) / 2) * angleStep;
    }
    const shift = (i - (n - 1) / 2) * baseShift;

    imgs += `<img
      src="${escapeHtml(photos[i])}"
      data-tidx="${tributeIdx}" data-pidx="${i}"
      class="fan-img transition-all focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-pink-300"
      style="z-index:${10 + i}; transform:translateX(${shift}px) rotate(${rot}deg);"
      tabindex="0"
      loading="lazy"
      alt="Tribute Photo ${i + 1} from ${fromName}"
      aria-label="View photo ${i+1} for tribute ${tributeIdx+1}">`;
  }
  // Ensure the container has the correct height even if images load slowly
  return `<div class="fan-gallery mb-4" style="height: 126px;">${imgs}</div>`;
}

function renderTributeCard(tribute, idx) {
  if (!tribute) return ''; // Safety check

  const icons = ['fa-flower', 'fa-apple-whole', 'fa-star', 'fa-heart', 'fa-seedling', 'fa-book'];
  const editDeleteButtons = `
    <div class="absolute top-2 right-2 flex gap-1 opacity-10 group-hover:opacity-95 focus-within:opacity-95 transition-opacity duration-200 z-20">
      <button class="edit-btn text-indigo-500 hover:text-indigo-700 p-1.5 focus:outline-none rounded-full hover:bg-indigo-100 focus:bg-indigo-100 focus:ring-2 focus:ring-indigo-300" data-tooltip="Edit Tribute" aria-label="Edit tribute by ${escapeHtml(tribute.from || 'Anonymous')}">
        <i class="fa-solid fa-pen-to-square text-sm"></i>
      </button>
      <button class="remove-btn text-pink-500 hover:text-pink-700 p-1.5 focus:outline-none rounded-full hover:bg-pink-100 focus:bg-pink-100 focus:ring-2 focus:ring-pink-300" data-tooltip="Delete Tribute" aria-label="Delete tribute by ${escapeHtml(tribute.from || 'Anonymous')}">
        <i class="fa-solid fa-trash text-sm"></i>
      </button>
    </div>
  `;

  return `
    <div class="card-animated rounded-2xl px-5 pt-7 pb-8 flex flex-col items-center min-h-[306px] shadow-lg border border-purple-100 group" data-tribute-index="${idx}">
      ${editDeleteButtons}
      ${renderFanGallery(tribute.photos, idx)}
      <div class="text-purple-600 font-bold mb-1 text-lg text-center" style="font-family: 'Indie Flower', cursive;">${escapeHtml(tribute.from || "Anonymous")}</div>
      <div class="text-gray-700 mb-4 text-center whitespace-pre-line flex-grow w-full" style="font-family:'Indie Flower',cursive;font-size:1.13rem;">${escapeHtml(tribute.msg)}</div>
      <div class="text-xs text-pink-400 absolute bottom-3 left-1/2 transform -translate-x-1/2 flex items-center gap-1 mt-auto">
        <i class="fa-solid ${icons[idx % icons.length]}"></i>
        <span>${escapeHtml(tribute.date || "")}</span>
      </div>
    </div>
  `;
}

function renderAllTributes() {
  const grid = document.getElementById("tributesGrid");
  const emptyState = document.getElementById('emptyState');
  grid.innerHTML = ""; // Clear previous content efficiently

  // Use the current global 'tributes' array
  if (!tributes.length) {
    emptyState.classList.remove('hidden');
    return;
  } else {
    emptyState.classList.add('hidden');
  }

  // Use a DocumentFragment for potentially better performance on large lists
  const fragment = document.createDocumentFragment();

  tributes.forEach((trb, idx) => {
    let cardWrapper = document.createElement('div'); // Temporary container
    cardWrapper.innerHTML = renderTributeCard(trb, idx).trim();
    const cardElement = cardWrapper.firstChild;

    if (cardElement) { // Ensure card element was created successfully
        // Attach Edit Listener
        const editBtn = cardElement.querySelector('.edit-btn');
        if (editBtn) {
            editBtn.onclick = (e) => {
                e.stopPropagation();
                startEditCard(idx, cardElement);
            };
        }

        // Attach Delete Listener
        const removeBtn = cardElement.querySelector('.remove-btn');
        if (removeBtn) {
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                // Use template literal for clarity, ensure name is escaped for display
                const confirmMsg = `Are you sure you want to delete the tribute from "${escapeHtml(trb.from || 'Anonymous')}"? This cannot be undone.`;
                if (confirm(confirmMsg)) {
                    const tributeToRemove = tributes[idx];
                    if (tributeToRemove.photos && tributeToRemove.photos.length > 0) {
                        tributeToRemove.photos.forEach(revokeBlobUrl); // Revoke associated blobs
                    }
                    tributes.splice(idx, 1); // Remove from global array
                    saveTributes(tributes); // Save updated array
                    renderAllTributes(); // Re-render the entire grid
                }
            };
        }
        fragment.appendChild(cardElement); // Add the card to the fragment
    } else {
        console.error("Failed to create card element for tribute:", trb);
    }
  });

  grid.appendChild(fragment); // Append all cards at once

  attachFanGalleryListeners(); // Attach listeners specific to fan images
  attachMobileCardAnimationObserver(); // Re-apply mobile scroll observer
}


// --- Edit Functionality ---
function startEditCard(idx, cardElem) {
    if (idx < 0 || idx >= tributes.length) {
        console.error("Invalid index for editing:", idx);
        renderAllTributes(); // Attempt to recover
        return;
    }
    let t = tributes[idx];
    if (!t) {
        console.error("Tribute data not found for editing at index:", idx);
        renderAllTributes();
        return;
    }

    cardElem.classList.add('editing');
    cardElem.classList.remove('group');

    const originalPhotos = [...(t.photos || [])];
    let currentEditPhotos = [...originalPhotos]; // Work with a mutable copy

    const generateEditFormHtml = (currentPhotos) => {
        // Generate HTML for current photos with remove buttons
        const photoElementsHtml = currentPhotos.map((ph, i) =>
            `<span class="relative group/img">
                <img src="${escapeHtml(ph)}" class="inline-block w-16 h-16 object-cover rounded-lg border-2 border-purple-200 shadow-md" alt="Photo ${i+1} preview">
                <button type="button" class="remove-img absolute -top-2 -right-2 text-sm text-center w-6 h-6 leading-6 bg-white border border-pink-400 text-pink-500 rounded-full hover:bg-pink-500 hover:text-white shadow-sm opacity-70 group-hover/img:opacity-100 transition-opacity focus:opacity-100 focus:ring-1 focus:ring-pink-400" data-phidx="${i}" data-tooltip="Remove Photo" aria-label="Remove photo ${i + 1}"><i class="fa fa-times"></i></button>
            </span>`
        ).join("");

        // Generate HTML for the file input label (conditionally)
        const addPhotoLabelHtml = currentPhotos.length < MAX_PHOTOS ? `
            <label class="w-full text-purple-500 font-medium text-xs mb-3 text-center cursor-pointer hover:text-pink-500 transition-colors block p-2 border border-dashed border-purple-300 rounded-lg bg-purple-50 hover:bg-purple-100">
                <i class="fa fa-image"></i> Add Photo(s) (${MAX_PHOTOS - currentPhotos.length} left)
                <input type="file" accept="image/*,.heic,.heif" class="edit-photo-uploader hidden" multiple>
            </label>` : '<div class="text-xs text-gray-400 mb-3 h-[40px] flex items-center justify-center">Photo limit reached</div>'; // Ensure consistent height

        // Assemble the full form HTML
        return `<form class='edit-tribute-form w-full h-full flex flex-col items-center justify-between p-4' autocomplete="off" aria-label="Editing tribute by ${escapeHtml(t.from || 'Anonymous')}">
            <input type="text" name="editFromName" class="edit-input font-bold px-3 py-1.5 rounded-xl border border-purple-300 w-4/5 my-2 text-purple-600 text-lg text-center focus:ring-2 focus:ring-pink-200 focus:outline-none" maxlength="${MAX_NAME_LENGTH}" value="${escapeHtml(t.from)}" placeholder="Your Name" required>
            <textarea name="editMessage" class="edit-textarea px-3 py-1.5 rounded-xl border border-purple-300 w-full my-1 mb-2 text-gray-700 text-center resize-none focus:ring-2 focus:ring-pink-200 focus:outline-none flex-grow min-h-[80px]" maxlength="${MAX_MSG_LENGTH}" rows="4" placeholder="Your message..." required>${escapeHtml(t.msg)}</textarea>
            <div class='flex justify-center flex-wrap gap-2 mb-3 min-h-[70px] w-full items-center'>
                ${photoElementsHtml || '<span class="text-xs text-gray-400">No photos added.</span>'}
            </div>
            ${addPhotoLabelHtml}
            <div class="edit-actions mt-auto w-full flex justify-center gap-3">
                <button type="submit" class="bg-gradient-to-r from-green-300 to-emerald-400 hover:from-green-400 hover:to-emerald-500 text-white font-semibold py-1.5 px-4 rounded-lg shadow hover:shadow-md transition-all transform active:scale-95 text-sm">Save Changes</button>
                <button type="button" class="bg-gradient-to-r from-pink-200 to-rose-300 hover:from-pink-300 hover:to-rose-400 text-rose-700 font-semibold py-1.5 px-4 rounded-lg shadow hover:shadow-md transition-all transform active:scale-95 text-sm cancel-edit-btn">Cancel</button>
            </div>
        </form>`;
    }

    // Function to attach listeners to the elements within the edit form
    const attachEditFormListeners = () => {
        // Remove photo listener
        cardElem.querySelectorAll('.remove-img').forEach(btn => {
            // Use onclick for simplicity here, could upgrade to addEventListener
            btn.onclick = function() {
                let phidx = parseInt(btn.getAttribute('data-phidx'));
                if (phidx >= 0 && phidx < currentEditPhotos.length) {
                    const removedUrl = currentEditPhotos.splice(phidx, 1)[0];
                    // IMPORTANT: Only revoke if it's a NEW blob URL (not saved originally)
                    if (removedUrl.startsWith('blob:') && !originalPhotos.includes(removedUrl)) {
                        revokeBlobUrl(removedUrl);
                    }
                    // Re-render form and re-attach listeners
                    cardElem.innerHTML = generateEditFormHtml(currentEditPhotos);
                    attachEditFormListeners();
                }
            }
        });

        // Add photo listener
        const photoUploader = cardElem.querySelector('.edit-photo-uploader');
        if (photoUploader) {
            photoUploader.onchange = function(e) {
                let files = Array.from(e.target.files);
                let addedCount = 0;
                files.forEach(f => {
                    if (currentEditPhotos.length < MAX_PHOTOS && f.type.startsWith('image/') && f.size < MAX_PHOTO_SIZE_MB * 1024 * 1024) {
                        let url = URL.createObjectURL(f);
                        currentEditPhotos.push(url); // Add to the working copy
                        addedCount++;
                    } else if (currentEditPhotos.length >= MAX_PHOTOS) {
                         alert(`Cannot add "${f.name}": Photo limit (${MAX_PHOTOS}) reached.`);
                         return; // Stop processing more files if limit hit
                    } else if (f.size >= MAX_PHOTO_SIZE_MB * 1024 * 1024) {
                        alert(`"${f.name}" is too large (max ${MAX_PHOTO_SIZE_MB}MB).`);
                    } else if (!f.type.startsWith('image/')) {
                         alert(`"${f.name}" is not a recognized image file.`);
                    }
                });
                if (addedCount > 0) {
                    cardElem.innerHTML = generateEditFormHtml(currentEditPhotos);
                    attachEditFormListeners();
                }
                e.target.value = null; // Reset file input
            }
        }

        // Cancel button listener
        cardElem.querySelector('.cancel-edit-btn').onclick = function() {
            // Revoke any NEWLY added blob URLs before cancelling
            currentEditPhotos.forEach(ph => {
                if (ph.startsWith('blob:') && !originalPhotos.includes(ph)) {
                    revokeBlobUrl(ph);
                }
            });
            // Restore card by re-rendering the entire grid (simplest way to restore state)
            renderAllTributes();
        }

        // Form submission (Save) listener
        cardElem.querySelector('.edit-tribute-form').onsubmit = function(e) {
            e.preventDefault();
            const newName = cardElem.querySelector('.edit-input').value.trim().slice(0, MAX_NAME_LENGTH) || "Anonymous";
            const newMsg = cardElem.querySelector('.edit-textarea').value.trim().slice(0, MAX_MSG_LENGTH);

             if (!newMsg) { // Basic validation
                alert("Message cannot be empty.");
                cardElem.querySelector('.edit-textarea').focus();
                return;
            }

            // Update the actual tribute object in the global array
            tributes[idx].from = newName;
            tributes[idx].msg = newMsg;
            tributes[idx].photos = [...currentEditPhotos]; // Assign the updated photo array
            tributes[idx].date = formatNow() + " (edited)";

            // Revoke ORIGINAL blob URLs that are NO LONGER in the list
             originalPhotos.forEach(ph => {
                if (ph.startsWith('blob:') && !currentEditPhotos.includes(ph)) {
                    revokeBlobUrl(ph);
                }
            });

            saveTributes(tributes); // Save the updated global array
            renderAllTributes(); // Re-render grid
        }
    }

    // Initial render of the form and attachment of listeners
    cardElem.innerHTML = generateEditFormHtml(currentEditPhotos);
    attachEditFormListeners();
    cardElem.querySelector('.edit-input')?.focus(); // Focus name input
}


// --- Event Listeners & Initialization ---

// Form Submission Handler (Add New Tribute)
document.getElementById('tributeForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const nameInput = document.getElementById('fromName');
    const msgInput = document.getElementById('message');
    const photoInput = document.getElementById('photos');

    const name = nameInput.value.trim().slice(0, MAX_NAME_LENGTH) || "Anonymous";
    const msg = msgInput.value.trim().slice(0, MAX_MSG_LENGTH);
    const date = formatNow();
    const files = photoInput.files;
    let photos = [];
    let addedUrls = []; // Track blobs created in this submission

    if (!msg) {
        alert("Please enter a message for your tribute.");
        msgInput.focus();
        return; // Stop submission if message is empty
    }

    if (files.length) {
        for (let i = 0; i < Math.min(files.length, MAX_PHOTOS); i++) {
            const file = files[i];
            if (file.type.startsWith("image/") && file.size < MAX_PHOTO_SIZE_MB * 1024 * 1024) {
                const objectURL = URL.createObjectURL(file);
                photos.push(objectURL);
                addedUrls.push(objectURL); // Track for potential immediate revoke if needed
            } else if (file.size >= MAX_PHOTO_SIZE_MB * 1024 * 1024) {
                alert(`Skipping "${file.name}": File is too large (max ${MAX_PHOTO_SIZE_MB}MB).`);
            } else if (!file.type.startsWith("image/")) {
                alert(`Skipping "${file.name}": File is not a recognized image type.`);
            }
        }
         if (files.length > MAX_PHOTOS) {
            alert(`Only the first ${MAX_PHOTOS} valid photos were added.`);
        }
    }

    // Add the new tribute (with a generated ID)
    tributes.unshift({ id: generateId(), from: name, msg, date, photos });
    saveTributes(tributes);
    renderAllTributes();

    // Reset the form for the next submission
    this.reset(); // 'this' refers to the form element

    // Note: We rely on the beforeunload handler and edit/delete logic to revoke blobs.
    // Revoking 'addedUrls' here immediately is risky if rendering takes time.
});


// Fan Gallery Image Listeners
function attachFanGalleryListeners() {
  document.querySelectorAll('.fan-img').forEach(img => {
    // Use addEventListener for better control (e.g., removing later if needed)
    const clickHandler = (e) => {
      // Prevent clicks on buttons inside the card triggering the modal
      if (e.target.closest('.edit-btn') || e.target.closest('.remove-btn')) {
          return;
      }
      e.stopPropagation();
      const tIdx = parseInt(img.getAttribute("data-tidx"));
      const pIdx = parseInt(img.getAttribute("data-pidx"));
      if (!isNaN(tIdx) && !isNaN(pIdx) && tIdx < tributes.length) { // Add bounds check
        showModalGallery(tIdx, pIdx);
      } else {
          console.warn("Invalid tribute/photo index on fan image:", img);
      }
    };

    const keydownHandler = (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        clickHandler(e); // Simulate click on Enter/Space
      }
    };

    const mouseEnterHandler = () => {
      if (window.innerWidth > 768 && !img.closest('.card-animated.editing')) {
        img.classList.add('fan-anim');
      }
    };

    const mouseLeaveHandler = () => {
      img.classList.remove('fan-anim');
    };

    // Clean up previous listeners if any (important if called multiple times)
    img.removeEventListener('click', clickHandler);
    img.removeEventListener('keydown', keydownHandler);
    img.removeEventListener('mouseenter', mouseEnterHandler);
    img.removeEventListener('mouseleave', mouseLeaveHandler);
    img.removeEventListener('focus', mouseEnterHandler); // Assuming focus acts like hover
    img.removeEventListener('blur', mouseLeaveHandler);

    // Add new listeners
    img.addEventListener('click', clickHandler);
    img.addEventListener('keydown', keydownHandler);
    img.addEventListener('mouseenter', mouseEnterHandler);
    img.addEventListener('mouseleave', mouseLeaveHandler);
    img.addEventListener('focus', mouseEnterHandler);
    img.addEventListener('blur', mouseLeaveHandler);
  });
}

// Mobile Card Animation Observer
let cardObserver = null;
function attachMobileCardAnimationObserver() {
    if (!('IntersectionObserver' in window)) return;

    if (cardObserver) cardObserver.disconnect(); // Disconnect old observer

    cardObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const card = entry.target;
            if (card.classList.contains('editing')) return; // Skip if editing

            if (entry.isIntersecting) {
                card.classList.add('mobile-anim');
                setTimeout(() => card.classList.remove('mobile-anim'), 800);
                // Optional: Unobserve after first animation
                // cardObserver.unobserve(card);
            } else {
                card.classList.remove('mobile-anim');
            }
        });
    }, { threshold: 0.3 }); // Adjust threshold if needed (30% visibility)

    // Observe only non-editing cards
    document.querySelectorAll('.card-animated:not(.editing)').forEach(card => {
        card.classList.remove('mobile-anim'); // Reset state
        cardObserver.observe(card);
    });
}


// --- Image Modal Gallery Logic ---
const modal = document.getElementById("galleryModal");
const modalContent = modal.querySelector(".relative");
const modalImg = document.getElementById('modalImg');
const modalCaption = document.getElementById('galleryCaption');
const prevBtn = document.getElementById('prevImgBtn');
const nextBtn = document.getElementById('nextImgBtn');
const closeBtn = document.getElementById('closeModalBtn');
const modalBG = document.getElementById('modalBG');

function showModalGallery(tributeIdx, photoIdx) {
  if (tributeIdx < 0 || tributeIdx >= tributes.length) return; // Bounds check

  currentModalTributeIdx = tributeIdx;
  currentModalPhotoIdx = photoIdx;
  renderModalImage(); // Load first image

  modal.classList.remove("hidden");
  requestAnimationFrame(() => { // Use rAF for smooth transition start
    modal.style.opacity = '1';
    modalContent.style.opacity = '1';
    modalContent.style.transform = 'scale(1)';
  });
  document.body.style.overflow = 'hidden';
  // Focus the close button or modal container for accessibility
  closeBtn.focus();
}

function renderModalImage() {
  const t = tributes[currentModalTributeIdx];
  if (!t || !t.photos || t.photos.length === 0) {
    closeModalGallery(); // Close if data is invalid
    return;
  }
  const photos = t.photos;
  // Ensure photo index is valid
  if (currentModalPhotoIdx < 0 || currentModalPhotoIdx >= photos.length) {
      currentModalPhotoIdx = 0; // Reset to first image if index is out of bounds
  }
  const currentPhotoUrl = photos[currentModalPhotoIdx];

  modalImg.src = escapeHtml(currentPhotoUrl); // Set image source safely
  modalImg.alt = `Image ${currentModalPhotoIdx + 1} of ${photos.length} for tribute by ${escapeHtml(t.from || 'Anonymous')}`;
  modalCaption.textContent = `"${escapeHtml(t.from || 'Anonymous')}" - Photo ${currentModalPhotoIdx + 1} / ${photos.length}`;

  // Manage button states
  prevBtn.disabled = currentModalPhotoIdx === 0;
  nextBtn.disabled = currentModalPhotoIdx === photos.length - 1;
  prevBtn.classList.toggle('hidden', photos.length <= 1);
  nextBtn.classList.toggle('hidden', photos.length <= 1);
}

function closeModalGallery() {
  modal.style.opacity = '0';
  modalContent.style.opacity = '0';
  modalContent.style.transform = 'scale(0.95)';
  // Use transitionend event for more reliable hiding after animation
  modal.addEventListener('transitionend', function handler(e) {
      // Only react to the opacity transition ending on the modal itself
      if (e.propertyName === 'opacity' && e.target === modal) {
          modal.classList.add("hidden");
          modalImg.src = ''; // Clear src to free memory
          document.body.style.overflow = '';
          modal.removeEventListener('transitionend', handler); // Clean up listener
      }
  }, { once: true }); // Automatically remove listener after it runs once

  // Fallback timeout in case transitionend doesn't fire (e.g., display:none)
  setTimeout(() => {
      if (!modal.classList.contains("hidden")) {
          modal.classList.add("hidden");
          modalImg.src = '';
          document.body.style.overflow = '';
      }
  }, 350); // Slightly longer than CSS transition
}

// Modal Event Listeners (using addEventListener)
closeBtn.addEventListener('click', closeModalGallery);
modalBG.addEventListener('click', closeModalGallery);

prevBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (currentModalPhotoIdx > 0) {
    currentModalPhotoIdx--;
    renderModalImage();
  }
});

nextBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const t = tributes[currentModalTributeIdx];
  if (t && t.photos && currentModalPhotoIdx < t.photos.length - 1) {
    currentModalPhotoIdx++;
    renderModalImage();
  }
});

// Keyboard Navigation for Modal
window.addEventListener("keydown", (e) => {
  if (modal.classList.contains("hidden")) return;

  let handled = false;
  if (e.key === "ArrowLeft") {
    if (!prevBtn.disabled) prevBtn.click();
    handled = true;
  } else if (e.key === "ArrowRight") {
    if (!nextBtn.disabled) nextBtn.click();
    handled = true;
  } else if (e.key === "Escape") {
    closeModalGallery();
    handled = true;
  }

  if (handled) {
      e.preventDefault(); // Prevent default browser action (scrolling)
  }
});


// --- Page Load / Unload ---

document.addEventListener("DOMContentLoaded", () => {
  renderAllTributes(); // Initial render of tributes

  // Grid intro animation
  const grid = document.getElementById('tributesGrid');
  if (grid) {
      grid.style.opacity = '0';
      grid.style.transform = 'translateY(20px)';
      setTimeout(() => {
          grid.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
          grid.style.opacity = '1';
          grid.style.transform = 'translateY(0)';
      }, 100);
  } else {
      console.error("Tributes grid element not found!");
  }
});

// Cleanup blob URLs on page unload
window.addEventListener('beforeunload', () => {
  console.log("Cleaning up blob URLs before page unload...");
  tributes.forEach(t => {
    if (t.photos && t.photos.length > 0) {
      t.photos.forEach(revokeBlobUrl);
    }
  });
  // Note: This runs *before* the page unloads.
  // It doesn't guarantee completion if the browser closes abruptly.
});

</script>
</body>
</html>
